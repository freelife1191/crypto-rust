// Automatically generated by flapigen
package com.freelife.crypto.core;

import java.io.File;
import java.io.InputStream;
import java.lang.ref.Cleaner;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Stream;

public final class CryptoSession implements AutoCloseable {

    private static final Cleaner cleaner = Cleaner.create();
    private final Cleaner.Cleanable cleanable;
    /*package*/ long mNativeObj;

    private CryptoSession(String path) throws CryptoException {
        mNativeObj = init(path);
        CRYPTO_BASE_PATHS = null;
        cleanable = cleaner.register(this, new State(mNativeObj));
    }
    private CryptoSession(byte [] bytes) throws CryptoException {
        mNativeObj = init(bytes);
        CRYPTO_BASE_PATHS = null;
        cleanable = cleaner.register(this, new State(mNativeObj));
    }

    private CryptoSession(String aws_kms_key, String access_key_id, String secret_access_key, String seed, String credential) throws CryptoException {
        mNativeObj = init(aws_kms_key, access_key_id, secret_access_key, seed, credential);
        CRYPTO_BASE_PATHS = null;
        cleanable = cleaner.register(this, new State(mNativeObj));
    }
    /*package*/ CryptoSession(InternalPointerMarker marker, long ptr) {
        assert marker == InternalPointerMarker.RAW_PTR;
        this.mNativeObj = ptr;
        this.CRYPTO_BASE_PATHS = null;
        this.cleanable = null;
    }

    public String encrypt(String plaintext) throws CryptoException {
        return do_encrypt(mNativeObj, plaintext);
    }
    public String decrypt(String encrypted) throws CryptoException {
        return do_decrypt(mNativeObj, encrypted);
    }

    public synchronized void delete() {
        if (mNativeObj != 0) {
            do_delete(mNativeObj);
            mNativeObj = 0;
       }
    }

    @Override
    public void close() throws CryptoException {
        delete();
    }

    private static native long init(String path) throws CryptoException;
    private static native long init(byte [] bytes) throws CryptoException;
    private static native long init(String aws_kms_key, String access_key_id, String secret_access_key, String seed, String credential) throws CryptoException;
    private static native String do_encrypt(long self, String plaintext) throws CryptoException;
    private static native String do_decrypt(long self, String encrypted) throws CryptoException;
    private static native void do_delete(long me);

    private static class State implements Runnable {
        private long mNativeObj;

        State(long mNativeObj) {
            this.mNativeObj = mNativeObj;
        }

        @Override
        public void run() {
            if (mNativeObj != 0) {
                do_delete(mNativeObj);
            }
        }
    }

    static {
        try {
            NativeUtils.loadLibraryFromJar();
        } catch (java.io.IOException e) {
            throw new CryptoException(e);
        }
    }


    private static volatile CryptoSession CRYPTO_SESSION_INSTANCE = null;

    private final List<Path> CRYPTO_BASE_PATHS;
    private Path CRYPTO_APPLY_PATH;

    private CryptoSession() {
        CRYPTO_BASE_PATHS = new ArrayList<>();
        CRYPTO_BASE_PATHS.add(Path.of("crypto","config.json").toAbsolutePath());
        CRYPTO_BASE_PATHS.add(Path.of("crypto","config.json"));
        CRYPTO_BASE_PATHS.add(Path.of(File.separator,"var", "opt", "crypto","config.json"));
        for (Path path : CRYPTO_BASE_PATHS) {
            if (Files.exists(path)) {
                CRYPTO_APPLY_PATH = path;
                break;
            }
        }
        cleanable = cleaner.register(this, new State(mNativeObj));
    }

    private static CryptoSession getCryptoSession() {
        return new CryptoSession();
    }

    /**
     * 기본 경로에 있는 config.json 파일을 읽어서 CryptoSession 인스턴스를 생성합니다.
     * 기본 경로1: ${projectDir}/crypto/config.json
     * 기본 경로2: /var/opt/crypto/config.json
     * @return CryptoSession instance
     */
    public static CryptoSession getInstance() {
        if (getCryptoSession().CRYPTO_APPLY_PATH == null)
            throw new CryptoException("The config.json file cannot be found in the default path.");
        return GetCryptoSession(getCryptoSession().CRYPTO_APPLY_PATH.toString());
    }

    /**
     * path 경로에 있는 config.json 파일을 읽어서 CryptoSession 인스턴스를 생성합니다.
     * @param path config.json 파일의 경로
     * @return CryptoSession instance
     */
    public static CryptoSession getInstance(String path) {
        Path basePath = java.nio.file.Path.of(path).toAbsolutePath();
        return GetCryptoSession(basePath.toString());
    }

    /**
     * config.json 파일을 InputStream 형태로 읽어서 CryptoSession 인스턴스를 생성합니다.
     * @param inputStream config.json 파일을 읽어들인 InputStream
     * @return CryptoSession instance
     */
    public static CryptoSession getInstance(InputStream inputStream) {
        return GetCryptoSession(inputStream);
    }

    /**
     * config.json 파일을 읽어서 CryptoSession 인스턴스를 생성합니다.
     * @param bytes config.json 파일을 읽어들인 byte 배열
     * @return CryptoSession instance
     */
    public static CryptoSession getInstance(byte[] bytes) {
        return GetCryptoSession(bytes);
    }

    /**
     * Map 형태로 전달된 구성을 사용하여 CryptoSession 인스턴스를 생성합니다.
     * 구성 맵에는 다음 키가 포함되어야 합니다.
     * @param configMap(aws_kms_key_arn, aws_access_key_id, aws_secret_access_key, seed, credential) Config map
     * @return CryptoSession instance
     */
    public static CryptoSession getInstance(Map<String, String> configMap) {
        return GetCryptoSession(configMap);
    }

    /**
     * Singleton CryptoSession 인스턴스를 생성합니다.
     * @param object CryptoSession 인스턴스를 생성하기 위한 객체
     * @return CryptoSession instance
     */
    public static CryptoSession GetCryptoSession(Object object) {
        if (CRYPTO_SESSION_INSTANCE == null) {
            synchronized (com.freelife.crypto.core.CryptoSession.class) {
                if (CRYPTO_SESSION_INSTANCE == null) {
                    try {

                        initCryptoSession(object);
                    } catch (Exception e) {
                        throw new CryptoException(e);
                    }
                }
            }
        }
        return CRYPTO_SESSION_INSTANCE;
    }

    /**
     * CryptoSession 인스턴스를 초기화합니다.
     * @param object
     * @throws Exception
     */
    private static void initCryptoSession(Object object) throws Exception {

        writeLog("Initialize CryptoSession Bean");

        if (Objects.isNull(object))
            throw new CryptoException("Parameter must not be null");

        if (object instanceof byte[]) {
            CRYPTO_SESSION_INSTANCE = new CryptoSession((byte[]) object);
        } else if (object instanceof InputStream) {
            CRYPTO_SESSION_INSTANCE = new CryptoSession(((InputStream) object).readAllBytes());
        } else if (object instanceof Map) {
            Map<String, String> configMap = (Map<String, String>) object;
            String awsKmsKeyArn = configMap.get("aws_kms_key_arn");
            String awsAccessKeyId = configMap.get("aws_access_key_id");
            String awsSecretAccessKey = configMap.get("aws_secret_access_key");
            String seed = configMap.get("seed");
            String credential = configMap.get("credential");
            boolean allMatch = Stream.of(awsKmsKeyArn, awsAccessKeyId, awsSecretAccessKey, seed, credential)
                    .allMatch(s -> s != null && !s.isEmpty());
            if (allMatch)
                CRYPTO_SESSION_INSTANCE = new CryptoSession(awsKmsKeyArn, awsAccessKeyId, awsSecretAccessKey, seed, credential);
        } else if (object instanceof String) {
            if (getCryptoSession().CRYPTO_BASE_PATHS != null)
                writeLog("Default Crypto Config Paths: " + getCryptoSession().CRYPTO_BASE_PATHS);
            Path path = java.nio.file.Path.of((String) object).toAbsolutePath();
            writeLog("Apply Crypto Config Path: " + path);
            CRYPTO_SESSION_INSTANCE = new CryptoSession(path.toString());
        }

        if (CRYPTO_SESSION_INSTANCE == null)
            throw new CryptoException("Config file loading failed");
    }

    private static void writeLog(String message) {
        // return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS").format(new Date());
        String prefix = "[Crypto][INFO]";
        String now = OffsetDateTime.now().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
        System.out.format("%s[%s] %s\n",prefix, now, message);
    }

}