// Automatically generated by flapigen
package com.freelife.crypto.core;

import java.io.File;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Stream;
import java.lang.ref.Cleaner;

public final class CryptoSession implements AutoCloseable {
    private static final Cleaner cleaner = Cleaner.create();
    private final Cleaner.Cleanable cleanable;
    private volatile long mNativeObj;

    /**
     * 기본 경로에 있는 config.json 파일을 읽어서 CryptoSession 인스턴스를 생성합니다.
     * 기본 경로1: ${projectDir}/crypto/config.json
     * 기본 경로2: /var/opt/crypto/config.json
     */
    public CryptoSession() {
        List<Path> cryptoBasePaths = Arrays.asList(
                Path.of("crypto", "config.json").toAbsolutePath(),
                Path.of("crypto", "config.json"),
                Path.of(File.separator, "opt", "crypto", "config.json")
        );
        writeLog("Default Crypto Config Paths: " + cryptoBasePaths);
        Path cryptoApplyPath = cryptoBasePaths.stream()
                .filter(Files::exists)
                .findFirst()
                .orElseThrow(() -> new CryptoException("Could not find config.json file in default path"));
        writeLog("Apply Crypto Config Path: " + cryptoApplyPath);
        try {
            mNativeObj = init(cryptoApplyPath.toString());
            cleanable = cleaner.register(this, new State(mNativeObj));
        } catch (Exception e) {
            throw new CryptoException(e.getMessage());
        }
    }

    /**
     * path 경로에 있는 config.json 파일을 읽어서 CryptoSession 객체를 생성합니다.
     * @param path config.json 파일의 경로
     */
    public CryptoSession(String path) {
        if (path == null) throw new CryptoException("path is required");
        Path configPath = Path.of(path);
        if (!Files.exists(configPath)) throw new CryptoException("Could not find 'config.json' file at that path");
        try {
            mNativeObj = init(path);
            cleanable = cleaner.register(this, new State(mNativeObj));
        } catch (Exception e) {
            throw new CryptoException(e.getMessage());
        }
    }

    /**
     * config.json 파일을 InputStream 형태로 읽어서 CryptoSession 객체를 생성합니다.
     * @param inputStream config.json 파일을 읽어들인 InputStream
     */
    public CryptoSession(InputStream inputStream) {
        if (inputStream == null) throw new CryptoException("inputStream is required");
        byte[] bytes;
        try {
            bytes = inputStream.readAllBytes();
            mNativeObj = init(bytes);
            cleanable = cleaner.register(this, new State(mNativeObj));
        } catch (Exception e) {
            throw new CryptoException(e.getMessage());
        }
    }

    /**
     * config.json 파일을 읽어서 CryptoSession 객체를 생성합니다.
     * @param bytes config.json 파일을 읽어들인 byte 배열
     */
    public CryptoSession(byte[] bytes) {
        if (bytes == null) throw new CryptoException("bytes are required");
        try {
            mNativeObj = init(bytes);
            cleanable = cleaner.register(this, new State(mNativeObj));
        } catch (Exception e) {
            throw new CryptoException(e.getMessage());
        }
    }

    /**
     * Map 형태로 전달된 구성을 사용하여 CryptoSession 객체를 생성합니다.
     * 구성 맵에는 다음 키가 포함되어야 합니다.
     * @param configLocalMap configLocalMap(key, iv, seed, credential)
     */
    public CryptoSession(Map<String, String> configLocalMap, String key, String iv) {
        if (configLocalMap == null)
            throw new CryptoException("configLocalMap is required: Elements in configLocalMap must contain values for the keys (key, iv, seed, credential)");
        List<String> errors = new ArrayList<>();
        Stream.of("key", "iv", "seed", "credential")
                .forEach(it -> {
                    if (configLocalMap.get(it) == null || configLocalMap.get(it).isBlank()) errors.add(it);
                });
        if (!errors.isEmpty())
            throw new CryptoException("The config local map does not contain the required keys: " + errors);
        try {
            mNativeObj = init(configLocalMap.get("key"), configLocalMap.get("iv"), configLocalMap.get("seed"), configLocalMap.get("credential"));
            cleanable = cleaner.register(this, new State(mNativeObj));
        } catch (Exception e) {
            throw new CryptoException(e.getMessage());
        }
    }

    /**
     * Map 형태로 전달된 구성을 사용하여 CryptoSession 객체를 생성합니다.
     * 구성 맵에는 다음 키가 포함되어야 합니다.
     * @param configMap configMap(aws_kms_key_arn, aws_access_key_id, aws_secret_access_key, seed, credential)
     */
    public CryptoSession(Map<String, String> configMap) {
        if (configMap == null)
            throw new CryptoException("configMap is required: Elements in configMap must contain values for the keys (aws_kms_key_arn, aws_access_key_id, aws_secret_access_key, seed, credential)");
        List<String> errors = new ArrayList<>();
        Stream.of("aws_kms_key_arn", "aws_access_key_id", "aws_secret_access_key", "seed", "credential")
                .forEach(key -> {
                    if (configMap.get(key) == null || configMap.get(key).isBlank()) errors.add(key);
                });
        if (!errors.isEmpty())
            throw new CryptoException("The config map does not contain the required keys: " + errors);
        try {
            mNativeObj = init(configMap.get("aws_kms_key_arn"), configMap.get("aws_access_key_id"),
                    configMap.get("aws_secret_access_key"), configMap.get("seed"), configMap.get("credential"));
            cleanable = cleaner.register(this, new State(mNativeObj));
        } catch (Exception e) {
            throw new CryptoException(e.getMessage());
        }
    }

    /**
     * 파라메터를 전달하여 CryptoSession 객체를 생성합니다.
     * 파라메터는 다음 값들이 필수적으로 추가되어야 합니다.
     * @param key key
     * @param iv iv
     * @param seed seed
     * @param credential credential
     */
    public CryptoSession(String key, String iv, String seed, String credential) {
        List<String> errors = new ArrayList<>();
        if (key == null || key.isBlank()) errors.add("key");
        if (iv == null || iv.isBlank()) errors.add("iv");
        if (seed == null || seed.isBlank()) errors.add("seed");
        if (credential == null || credential.isBlank()) errors.add("credential");
        if (!errors.isEmpty())
            throw new CryptoException("The following parameters are required: " + errors);
        try {
            mNativeObj = init(key, iv, seed, credential);
            cleanable = cleaner.register(this, new State(mNativeObj));
        } catch (Exception e) {
            throw new CryptoException(e.getMessage());
        }
    }

    /**
     * 파라메터를 전달하여 CryptoSession 객체를 생성합니다.
     * 파라메터는 다음 값들이 필수적으로 추가되어야 합니다.
     * @param aws_kms_key_arn aws_kms_key_arn
     * @param aws_access_key_id aws_access_key_id
     * @param aws_secret_access_key aws_secret_access_key
     * @param seed seed
     * @param credential credential
     */
    public CryptoSession(String aws_kms_key_arn, String aws_access_key_id, String aws_secret_access_key, String seed, String credential) {
        List<String> errors = new ArrayList<>();
        if (aws_kms_key_arn == null || aws_kms_key_arn.isBlank()) errors.add("aws_kms_key_arn");
        if (aws_access_key_id == null || aws_access_key_id.isBlank()) errors.add("aws_access_key_id");
        if (aws_secret_access_key == null || aws_secret_access_key.isBlank()) errors.add("aws_secret_access_key");
        if (seed == null || seed.isBlank()) errors.add("seed");
        if (credential == null || credential.isBlank()) errors.add("credential");
        if (!errors.isEmpty())
            throw new CryptoException("The following parameters are required: " + errors);
        try {
            mNativeObj = init(aws_kms_key_arn, aws_access_key_id, aws_secret_access_key, seed, credential);
            cleanable = cleaner.register(this, new State(mNativeObj));
        } catch (Exception e) {
            throw new CryptoException(e.getMessage());
        }
    }

    public String encrypt(String plaintext) {
        try {
            return do_encrypt(mNativeObj, plaintext);
        } catch (Exception e) {
            throw new CryptoException(e.getMessage());
        }
    }

    public String decrypt(String encrypted) {
        try {
            return do_decrypt(mNativeObj, encrypted);
        } catch (Exception e) {
            throw new CryptoException(e.getMessage());
        }
    }

    @Override
    public synchronized void close() {
        cleanable.clean();
    }

    private static final class State implements Runnable {
        private final long mNativeObj;

        public State(long mNativeObj) {
            this.mNativeObj = mNativeObj;
        }

        @Override
        public void run() {
            if (mNativeObj != 0) {
                do_delete(mNativeObj);
            }
        }
    }

    private static native long init(String path) throws Exception;
    private static native long init(byte[] bytes) throws Exception;
    private static native long init(String key, String iv, String seed, String credential) throws Exception;
    private static native long init(String aws_kms_key, String access_key_id, String secret_access_key, String seed, String credential) throws Exception;
    private static native String do_encrypt(long self, String plaintext) throws Exception;
    private static native String do_decrypt(long self, String encrypted) throws Exception;
    private static native void do_delete(long me);
    /*package*/ CryptoSession(InternalPointerMarker marker, long ptr) {
        assert marker == InternalPointerMarker.RAW_PTR;
        this.mNativeObj = ptr;
        this.cleanable = null;
    }

    private static void writeLog(String message) {
        String prefix = "[Crypto][INFO]";
        String now = OffsetDateTime.now().format(DateTimeFormatter.ISO_OFFSET_DATE_TIME);
        System.out.format("%s[%s] %s\n", prefix, now, message);
    }

    static {
        try {
            NativeUtils.loadLibraryFromJar();
        } catch (java.io.IOException e) {
            throw new CryptoException(e.getMessage());
        }
    }
}
